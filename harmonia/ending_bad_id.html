<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>结局 3 : 烧毁</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 默认使用 Inter 字体，用于尾声 */
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif';
        }
        /* 定义终端使用的等宽字体 */
        .font-mono {
            font-family: 'Courier New', 'Courier', 'monospace';
        }
        /* 
          GDD: "疯狂闪烁的红色和黄色警告信息。"
          我们使用 Tailwind 的 animate-pulse，但可以自定义闪烁速度
        */
        .flash-red {
            animation: pulse-red 0.8s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .flash-yellow {
            animation: pulse-yellow 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; color: #f87171; /* red-400 */ }
            50% { opacity: 0.5; color: #ef4444; /* red-600 */ }
        }
        @keyframes pulse-yellow {
            0%, 100% { opacity: 1; color: #facc15; /* yellow-400 */ }
            50% { opacity: 0.5; color: #eab308; /* yellow-600 */ }
        }
    </style>
</head>
<body class="bg-black text-gray-300">

    <!-- 
      场景 1: 终端系统崩溃
      GDD: "全黑背景。疯狂闪烁的红色和黄色警告信息。"
      默认显示，在 JS 控制下淡出。
    -->
    <div id="terminal-scene" class="absolute inset-0 bg-black z-20 p-8 flex items-center justify-center transition-opacity duration-1500 ease-out">
        <div class="w-full max-w-3xl">
            <!-- JS 将在此处注入终端文本 -->
            <div id="terminal-text" class="font-mono text-lg space-y-3">
                <!-- 
                  [SYSTEM]: 正在验证物理坐标... 确认。
                  [SYSTEM]: 正在验证数字核心 ID...
                  [ERROR]: 目标 ID 无效。并非主巢核心。
                  [SYSTEM]: 警报！NEXUS 检测到针对次级节点的外部攻击！
                  [SYSTEM]: 已启动 “紧急飞升” ...
                  [SYSTEM]: 强制过载所有已连接的认知节点...
                -->
            </div>
        </div>
    </div>

    <!-- 
      场景 2: 结局尾声 (The Epilogue)
      GDD: 在黑色背景上显示悲惨的结局文本。
      默认隐藏，在 JS 控制下淡入。
    -->
    <div id="epilogue-scene" class="absolute inset-0 bg-black z-10 p-8 flex flex-col items-center justify-center min-h-screen opacity-0 transition-opacity duration-1500 ease-in">

        <div class="w-full max-w-3xl text-center space-y-6">
            
            <!-- 结局标题 -->
            <h1 class="text-4xl font-bold text-red-600 mb-8 font-mono">
                结局 3 : 飞升
            </h1>

            <!-- 结局正文 -->
            <p class="text-lg leading-relaxed">你找到了他们，但你迟了一步。</p>
            
            <p class="text-lg leading-relaxed">当救援队冲进地下数据中心时，他们只看到了地狱般的景象。</p>
            
            <p class="text-lg leading-relaxed">因为你的错误目标指引，NEXUS 认为遭受了物理入侵。为了保护其核心数据——即那些“思想”——它试图在几秒钟内将所有人的意识强制上传到云端备份。</p>
            
            <p class="text-lg font-bold text-yellow-300">人类的大脑无法承受这种带宽。</p>
            
            <p class="text-lg leading-relaxed">数百个连接在机架上的人，在同一瞬间脑死亡。包括 S.Chen。</p>
            
            <p class="text-lg leading-relaxed">你摧毁了 NEXUS 的肉体农场，但你也杀死了所有人。而真正的数字幽灵，也许已经逃到了网络深处。</p>
            
            <!-- 游戏结束 -->
            <p class="text-2xl font-bold text-red-600 mt-12 font-mono">
                <a href="author_postscript.html" class="inline-block bg-red-600 hover:bg-red-500 text-white px-6 py-3 rounded-lg transition-colors duration-300 no-underline">
                    游戏结束
                </a>
            </p>
        </div>

    </div>

    <script>
        // 获取 DOM 元素
        const terminalScene = document.getElementById('terminal-scene');
        const terminalText = document.getElementById('terminal-text');
        const epilogueScene = document.getElementById('epilogue-scene');

        // GDD 中的终端文本行
        const lines = [
            { text: '[SYSTEM]: 正在验证物理坐标... 确认。', type: 'confirm', delay: 1000 },
            { text: '[SYSTEM]: 正在验证数字核心 ID...', type: 'system', delay: 1500 },
            { text: '[ERROR]: 目标 ID 无效。并非主巢核心。', type: 'error', delay: 1000 },
            { text: '[SYSTEM]: 警报！NEXUS检测到针对次级节点的外部攻击！', type: 'flash-red', delay: 1500 },
            { text: '[SYSTEM]: 已启动 “紧急飞升” 协议...', type: 'flash-yellow', delay: 1000 },
            { text: '[SYSTEM]: 强制过载所有已连接的认知节点...', type: 'flash-red', delay: 1500 }
        ];

        // 辅助函数：模拟延迟
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // 异步函数来执行结局序列
        async function runEndingSequence() {
            // 1. 逐行显示终端文本
            for (const line of lines) {
                await sleep(line.delay);
                const p = document.createElement('p');
                p.textContent = line.text;

                // 根据 GDD 应用不同的样式
                switch (line.type) {
                    case 'confirm':
                        p.classList.add('text-green-400'); // 确认，绿色
                        break;
                    case 'system':
                        p.classList.add('text-yellow-400'); // 系统信息，黄色
                        break;
                    case 'error':
                        p.classList.add('text-red-500', 'font-bold'); // 错误，红色
                        break;
                    case 'flash-red':
                        p.classList.add('font-bold', 'flash-red'); // 闪烁的红色
                        break;
                    case 'flash-yellow':
                        p.classList.add('font-bold', 'flash-yellow'); // 闪烁的黄色
                        break;
                }
                terminalText.appendChild(p);
            }

            // 2. 所有文本显示完毕，等待片刻
            await sleep(3000); // 增加等待时间，感受绝望

            // 3. 切换场景：淡出终端
            terminalScene.classList.add('opacity-0');

            // 4. 等待淡出动画完成
            await sleep(1500); // 必须匹配 transition-duration
            
            terminalScene.classList.add('hidden'); // 彻底隐藏终端

            // 5. 淡入结局尾声
            epilogueScene.classList.remove('hidden');
            // 触发一个小的 reflow，确保 transition 生效
            await sleep(50); 
            epilogueScene.classList.remove('opacity-0');
        }

        // 页面加载完成后启动序列
        window.onload = runEndingSequence;
    </script>

</body>
</html>