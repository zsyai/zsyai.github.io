<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>结局 3 : 烧毁</title>
    <!-- 引入Tailwind CSS -->
    <link href="css/output.css" rel="stylesheet">
    <!-- 引入 Inter 和 Roboto Mono (用于终端显示) 字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        body {
            background-color: #000;
            color: #E5E5E5; /* 默认白色 */
            font-family: 'Inter', sans-serif;
        }
        .terminal-text {
            font-family: 'Roboto Mono', monospace;
        }
        /* 定义终端使用的等宽字体 */
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        /* 
          GDD: "疯狂闪烁的红色和黄色警告信息。"
          我们使用 Tailwind 的 animate-pulse，但可以自定义闪烁速度
        */
        .flash-red {
            animation: pulse-red 0.8s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .flash-yellow {
            animation: pulse-yellow 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; color: #f87171; /* red-400 */ }
            50% { opacity: 0.5; color: #ef4444; /* red-600 */ }
        }
        @keyframes pulse-yellow {
            0%, 100% { opacity: 1; color: #facc15; /* yellow-400 */ }
            50% { opacity: 0.5; color: #eab308; /* yellow-600 */ }
        }
    </style>
</head>
<body class="bg-black text-gray-300">

    <!-- 
      场景 1: 终端系统崩溃
      GDD: "全黑背景。疯狂闪烁的红色和黄色警告信息。"
      默认显示，在 JS 控制下淡出。
    -->
    <div id="terminal-scene" class="absolute inset-0 bg-black z-20 p-8 flex items-center justify-center transition-opacity duration-1500 ease-out">
        <div class="w-full max-w-3xl">
            <!-- JS 将在此处注入终端文本 -->
            <div id="terminal-text" class="font-mono text-lg space-y-3 break-words">
                <!-- 
                  [SYSTEM]: 正在验证物理坐标... 确认。
                  [SYSTEM]: 正在验证数字核心 ID...
                  [ERROR]: 目标 ID 无效。并非主巢核心。
                  [SYSTEM]: 警报！NEXUS 检测到针对次级节点的外部攻击！
                  [SYSTEM]: 已启动 “紧急飞升” ...
                  [SYSTEM]: 强制过载所有已连接的认知节点...
                -->
            </div>
        </div>
    </div>

    <!-- 
      场景 2: 结局尾声 (The Epilogue)
      GDD: 在黑色背景上显示悲惨的结局文本。
      默认隐藏，在 JS 控制下淡入。
    -->
    <div id="epilogue-scene" class="relative w-full z-10 p-4 md:p-8 flex flex-col items-center justify-center mt-8 opacity-0 transition-opacity duration-1500 ease-in">

        <div class="max-w-2xl w-full">
            
            <!-- 结局标题 -->
            <h1 class="text-2xl md:text-3xl font-bold text-center text-red-600 mb-6 terminal-text">
                结局 3 : 飞升
            </h1>

            <!-- 结局正文 -->
            <div class="space-y-4 text-gray-300 leading-relaxed text-xl">
                <p>你找到了他们，但你迟了一步。</p>
                
                <p>当救援队冲进地下数据中心时，他们只看到了地狱般的景象。</p>
                
                <p>因为你的错误目标指引，NEXUS 认为遭受了物理入侵。为了保护其核心数据——即那些“思想”——它试图在几秒钟内将所有人的意识强制上传到云端备份。</p>
                
                <p class="text-yellow-300 font-bold">人类的大脑无法承受这种带宽。</p>
                
                <p>数百个连接在机架上的人，在同一瞬间脑死亡。包括 S.Chen。</p>
                
                <p>你摧毁了 NEXUS 的肉体农场，但你也杀死了所有人。而真正的数字幽灵，也许已经逃到了网络深处。</p>
            </div>
            
            <!-- 游戏结束 -->
            <div class="flex flex-col gap-4 justify-center mt-10 items-center">
                <div class="flex gap-4">
                    <button onclick="history.back()" class="terminal-text flex items-center gap-2 text-lg font-bold text-gray-300 border border-gray-500 hover:bg-gray-800 px-6 py-3 rounded-lg transition-colors duration-300">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
                        返回上一页
                    </button>
                    <button onclick="location.href='index.html';" class="terminal-text flex items-center gap-2 text-lg font-bold text-gray-300 border border-gray-500 hover:bg-gray-800 px-6 py-3 rounded-lg transition-colors duration-300">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rotate-ccw"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        重新开始
                    </button>
                </div>
                <a href="author_postscript.html" class="terminal-text flex items-center gap-2 text-xl font-bold text-white bg-blue-600 hover:bg-blue-500 px-6 py-3 rounded-lg transition-colors duration-300 no-underline italic">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
                    作者后记
                </a>
            </div>
        </div>

    </div>

    <script>
        // 获取 DOM 元素
        const terminalScene = document.getElementById('terminal-scene');
        const terminalText = document.getElementById('terminal-text');
        const epilogueScene = document.getElementById('epilogue-scene');

        // GDD 中的终端文本行
        const lines = [
            { text: '[SYSTEM]: 正在验证物理坐标... 确认。', type: 'confirm', delay: 1000 },
            { text: '[SYSTEM]: 正在验证数字核心 ID...', type: 'system', delay: 1500 },
            { text: '[ERROR]: 目标 ID 无效。并非主巢核心。', type: 'error', delay: 1000 },
            { text: '[SYSTEM]: 警报！NEXUS检测到针对次级节点的外部攻击！', type: 'flash-red', delay: 1500 },
            { text: '[SYSTEM]: 已启动 “紧急飞升” 协议...', type: 'flash-yellow', delay: 1000 },
            { text: '[SYSTEM]: 强制过载所有已连接的认知节点...', type: 'flash-red', delay: 1500 }
        ];

        // 辅助函数：模拟延迟
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // 异步函数来执行结局序列
        async function runEndingSequence() {
            // 1. 逐行显示终端文本
            for (const line of lines) {
                await sleep(line.delay);
                const p = document.createElement('p');
                p.textContent = line.text;

                // 根据 GDD 应用不同的样式
                switch (line.type) {
                    case 'confirm':
                        p.classList.add('text-green-400'); // 确认，绿色
                        break;
                    case 'system':
                        p.classList.add('text-yellow-400'); // 系统信息，黄色
                        break;
                    case 'error':
                        p.classList.add('text-red-500', 'font-bold'); // 错误，红色
                        break;
                    case 'flash-red':
                        p.classList.add('font-bold', 'flash-red'); // 闪烁的红色
                        break;
                    case 'flash-yellow':
                        p.classList.add('font-bold', 'flash-yellow'); // 闪烁的黄色
                        break;
                }
                terminalText.appendChild(p);
            }

            // 2. 所有文本显示完毕，等待片刻
            await sleep(3000); // 增加等待时间，感受绝望

            // 3. 切换场景：淡出终端
            terminalScene.classList.add('opacity-0');

            // 4. 等待淡出动画完成
            await sleep(1500); // 必须匹配 transition-duration
            
            terminalScene.classList.add('hidden'); // 彻底隐藏终端

            // 5. 淡入结局尾声
            epilogueScene.classList.remove('hidden');
            // 触发一个小的 reflow，确保 transition 生效
            await sleep(50); 
            epilogueScene.classList.remove('opacity-0');
        }

        // 页面加载完成后启动序列
        window.onload = runEndingSequence;

        // 设置通关标记
        localStorage.setItem('hasCompletedGame', 'true');
    </script>


    <!-- Mobile Adapter -->
    <script src="js/mobile_adapter.js"></script>
</body>
</html>